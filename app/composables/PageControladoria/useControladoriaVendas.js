import { ref, computed } from 'vue'
import { useAPIsupabase } from '~/composables/useAPIsupabase'

export const useControladoriaVendas = () => {
  const { fetchData, fetchAllData } = useAPIsupabase()
  const { error: logError } = useSecureLogger()
  
  // Estados reativos
  const vendasData = ref([])
  const loading = ref(false)
  const error = ref(null)
  
  // Fun√ß√£o para normalizar strings (remover acentos, espa√ßos, etc.)
  const normalizeString = (str) => {
    if (!str) return ''
    return str
      .toLowerCase()
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '')
      .replace(/[.\-_\s]/g, '')
  }
  
  // Fun√ß√£o para classificar bandeiras
  const classificarBandeira = (bandeira, modalidade) => {
    const bandeiraNorm = normalizeString(bandeira)
    const modalidadeNorm = normalizeString(modalidade)
    
    // VISA ELECTRON (D√©bito) - Captura todas as varia√ß√µes de d√©bito
    if (bandeiraNorm.includes('visa') && 
        (modalidadeNorm.includes('debito') || 
         modalidadeNorm.includes('debitoprepago') || 
         modalidadeNorm.includes('prepagodebito') ||
         modalidadeNorm.includes('prepagodbto') ||
         modalidadeNorm.includes('dbto') ||
         modalidadeNorm.includes('deb'))) {
      return 'VISA ELECTRON'
    }
    
    // VISA (Cr√©dito) - Apenas quando n√£o for d√©bito
    if (bandeiraNorm.includes('visa') && 
        !(modalidadeNorm.includes('debito') || 
          modalidadeNorm.includes('debitoprepago') || 
          modalidadeNorm.includes('prepagodebito') ||
          modalidadeNorm.includes('prepagodbto') ||
          modalidadeNorm.includes('dbto') ||
          modalidadeNorm.includes('deb'))) {
      return 'VISA'
    }
    
    // MAESTRO (D√©bito)
    if ((bandeiraNorm.includes('maestro') || bandeiraNorm.includes('mastercard') || bandeiraNorm.includes('master')) &&
        (modalidadeNorm.includes('debito') || modalidadeNorm.includes('debitoprepago'))) {
      return 'MAESTRO'
    }
    
    // MASTERCARD (Cr√©dito)
    if ((bandeiraNorm.includes('mastercard') || bandeiraNorm.includes('master')) && !modalidadeNorm.includes('debito')) {
      return 'MASTERCARD'
    }
    
    // ELO D√âBITO
    if (bandeiraNorm.includes('elo') && 
        (modalidadeNorm.includes('debito') || modalidadeNorm.includes('debitoprepago'))) {
      return 'ELO D√âBITO'
    }
    
    // ELO CR√âDITO
    if (bandeiraNorm.includes('elo') && !modalidadeNorm.includes('debito')) {
      return 'ELO CR√âDITO'
    }
    
    // BANESCARD D√âBITO
    if (bandeiraNorm.includes('banescard') && 
        (modalidadeNorm.includes('debito') || modalidadeNorm.includes('debitoprepago'))) {
      return 'BANESCARD D√âBITO'
    }
    
    // AMEX (sempre cr√©dito)
    if (bandeiraNorm.includes('amex') || bandeiraNorm.includes('american')) {
      return 'AMEX'
    }
    
    // HIPERCARD (sempre cr√©dito)
    if (bandeiraNorm.includes('hipercard') || bandeiraNorm.includes('hiper')) {
      return 'HIPERCARD'
    }
    
    // TRICARD (sempre cr√©dito)
    if (bandeiraNorm.includes('tricard') || bandeiraNorm.includes('tri')) {
      return 'TRICARD'
    }
    
    return 'OUTROS'
  }
  
  // Fun√ß√£o para determinar a modalidade de pagamento
  const determinarModalidade = (modalidade, numeroParcelas) => {
    const modalidadeNorm = normalizeString(modalidade)
    const parcelas = parseInt(numeroParcelas) || 1
    
    // Detecta todas as varia√ß√µes de d√©bito
    if (modalidadeNorm.includes('debito') || 
        modalidadeNorm.includes('debitoprepago') || 
        modalidadeNorm.includes('prepagodebito') ||
        modalidadeNorm.includes('prepagodbto') ||
        modalidadeNorm.includes('dbto') ||
        modalidadeNorm.includes('deb')) {
      return 'debito'
    }
    
    if (modalidadeNorm.includes('voucher') || modalidadeNorm.includes('alimentacao') || modalidadeNorm.includes('refeicao')) {
      return 'voucher'
    }
    
    // Cr√©dito baseado no n√∫mero de parcelas
    if (parcelas === 1) return 'credito'
    if (parcelas === 2) return 'credito2x'
    if (parcelas === 3) return 'credito3x'
    if (parcelas >= 4 && parcelas <= 6) return 'credito4x5x6x'
    
    return 'outros'
  }
  
  // Fun√ß√£o para buscar dados da tabela vendas_norte_atacado_unica
  const buscarVendasUnica = async (filtros = {}) => {
    loading.value = true
    error.value = null
    
    try {
      const colunas = 'bandeira, adquirente, valor_bruto, valor_liquido, despesa_mdr, numero_parcelas, modalidade'
      
      console.log('üîç Buscando dados com filtros:', filtros)
      
      // Primeiro, verificar se a tabela existe e tem dados
      const totalRegistros = await fetchData('vendas_norte_atacado_unica', 'count(*)', {}, 1)
      console.log('üìà Total de registros na tabela:', totalRegistros)
      
      // Buscar TODOS os dados usando pagina√ß√£o (sem limite de 1000)
      console.log('üöÄ Buscando TODOS os registros da tabela (sem limite)...')
      const dados = await fetchAllData('vendas_norte_atacado_unica', colunas, filtros)
      
      console.log('üìä Dados retornados:', dados?.length || 0, 'registros')
      
      if (dados && dados.length > 4000) {
        console.log('‚úÖ Sucesso! Carregados mais de 4.000 registros:', dados.length)
      } else if (dados && dados.length > 0) {
        console.log('‚úÖ Registros carregados:', dados.length)
      }
      console.log('üìã Primeiros 3 registros:', dados?.slice(0, 3))
      
      // Verificar especificamente VISA + d√©bito
      if (dados && dados.length > 0) {
        const visaDebito = dados.filter(item => 
          item.bandeira?.toLowerCase().includes('visa') && 
          item.modalidade?.toLowerCase().includes('debito')
        )
        console.log('üí≥ VISA D√©bito encontrados:', visaDebito.length, 'registros')
        
        const somaValorLiquido = visaDebito.reduce((sum, item) => sum + (parseFloat(item.valor_liquido) || 0), 0)
        const somaValorBruto = visaDebito.reduce((sum, item) => sum + (parseFloat(item.valor_bruto) || 0), 0)
        
        console.log('üí∞ Soma VISA D√©bito (Valor L√≠quido):', somaValorLiquido.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' }))
        console.log('üí∞ Soma VISA D√©bito (Valor Bruto):', somaValorBruto.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' }))
        
        // Mostrar alguns exemplos
        console.log('üìã Primeiros 5 registros VISA D√©bito:', visaDebito.slice(0, 5).map(item => ({
          bandeira: item.bandeira,
          modalidade: item.modalidade,
          valor_bruto: item.valor_bruto,
          valor_liquido: item.valor_liquido
        })))
      }
      
      if (dados && dados.length > 0) {
        vendasData.value = dados
        return dados
      } else {
        console.warn('‚ö†Ô∏è Nenhum dado encontrado na tabela vendas_norte_atacado_unica')
        vendasData.value = []
        return []
      }
      
    } catch (err) {
      console.error('‚ùå Erro detalhado ao buscar dados:', err)
      
      if (err.message?.includes('relation') || err.message?.includes('table')) {
        console.error('üö´ Tabela "vendas_norte_atacado_unica" n√£o encontrada!')
        error.value = 'Tabela vendas_norte_atacado_unica n√£o encontrada no banco de dados'
      } else {
        error.value = err.message
      }
      
      logError('Erro ao buscar vendas √∫nica', { error: err.message, stack: err.stack })
      
      // Retornar dados de exemplo para teste
      console.warn('‚ö†Ô∏è Retornando dados de exemplo para teste...')
      const dadosExemplo = [
        {
          bandeira: 'VISA',
          modalidade: 'DEBITO',
          valor_liquido: 50000.00,
          valor_bruto: 52000.00,
          despesa_mdr: 2000.00,
          numero_parcelas: 1,
          adquirente: 'STONE'
        },
        {
          bandeira: 'VISA ELECTRON',
          modalidade: 'DEBITO PREPAGO',
          valor_liquido: 84670.31,
          valor_bruto: 86000.00,
          despesa_mdr: 1329.69,
          numero_parcelas: 1,
          adquirente: 'CIELO'
        }
      ]
      
      vendasData.value = dadosExemplo
      return dadosExemplo
    } finally {
      loading.value = false
    }
  }
  
  // Computed para agrupar dados por bandeira classificada
  const vendasAgrupadas = computed(() => {
    const grupos = {}
    
    console.log('üîÑ Processando', vendasData.value.length, 'registros para agrupamento')
    
    vendasData.value.forEach((venda, index) => {
      const bandeiraClassificada = classificarBandeira(venda.bandeira, venda.modalidade)
      const modalidadePagamento = determinarModalidade(venda.modalidade, venda.numero_parcelas)
      
      // Log detalhado para VISA
      if (venda.bandeira?.toLowerCase().includes('visa')) {
        console.log(`üìù VISA ${index + 1}:`, {
          bandeira_original: venda.bandeira,
          modalidade_original: venda.modalidade,
          bandeira_classificada: bandeiraClassificada,
          modalidade_pagamento: modalidadePagamento,
          valor_liquido: venda.valor_liquido
        })
      }
      
      if (!grupos[bandeiraClassificada]) {
        grupos[bandeiraClassificada] = {
          adquirente: bandeiraClassificada,
          debito: 0,
          credito: 0,
          credito2x: 0,
          credito3x: 0,
          credito4x5x6x: 0,
          voucher: 0,
          outros: 0,
          valor_bruto_total: 0,
          valor_liquido_total: 0,
          despesa_mdr_total: 0
        }
      }
      
      const grupo = grupos[bandeiraClassificada]
      const valorLiquido = parseFloat(venda.valor_liquido) || 0
      const valorBruto = parseFloat(venda.valor_bruto) || 0
      const despesaMdr = parseFloat(venda.despesa_mdr) || 0
      
      // Log espec√≠fico para VISA ELECTRON
      if (bandeiraClassificada === 'VISA ELECTRON') {
        console.log(`üí≥ Somando VISA ELECTRON:`, {
          modalidade: modalidadePagamento,
          valor_bruto: valorBruto,
          valor_liquido: valorLiquido,
          valor_anterior: grupo[modalidadePagamento],
          valor_novo: grupo[modalidadePagamento] + valorBruto
        })
      }
      
      // Somar valores por modalidade - USAR VALOR_BRUTO para as modalidades
      grupo[modalidadePagamento] += valorBruto
      grupo.valor_bruto_total += valorBruto
      grupo.valor_liquido_total += valorLiquido
      grupo.despesa_mdr_total += despesaMdr
    })
    
    const resultado = Object.values(grupos)
    console.log('üìä Resultado final do agrupamento:', resultado)
    
    // Log espec√≠fico para VISA ELECTRON
    const visaElectron = resultado.find(g => g.adquirente === 'VISA ELECTRON')
    if (visaElectron) {
      console.log('üí≥ VISA ELECTRON final na tabela:', visaElectron)
      console.log('üí∞ VISA ELECTRON D√©bito (valor que aparece na tabela):', 
        visaElectron.debito.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' }))
      console.log('üí∞ VISA ELECTRON Total Bruto:', 
        visaElectron.valor_bruto_total.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' }))
    } else {
      console.log('‚ö†Ô∏è VISA ELECTRON n√£o encontrado no resultado final')
    }
    
    return resultado
  })
  
  // Computed para totais gerais
  const totaisGerais = computed(() => {
    return vendasAgrupadas.value.reduce((acc, grupo) => {
      acc.vendaLiquida += grupo.valor_liquido_total
      acc.vendaBruta += grupo.valor_bruto_total
      acc.despesaMdr += grupo.despesa_mdr_total
      acc.debito += grupo.debito
      acc.credito += grupo.credito
      acc.credito2x += grupo.credito2x
      acc.credito3x += grupo.credito3x
      acc.credito4x5x6x += grupo.credito4x5x6x
      acc.voucher += grupo.voucher
      acc.outros += grupo.outros
      return acc
    }, {
      vendaLiquida: 0,
      vendaBruta: 0,
      despesaMdr: 0,
      debito: 0,
      credito: 0,
      credito2x: 0,
      credito3x: 0,
      credito4x5x6x: 0,
      voucher: 0,
      outros: 0
    })
  })
  
  return {
    // Estados
    vendasData,
    loading,
    error,
    
    // Computed
    vendasAgrupadas,
    totaisGerais,
    
    // M√©todos
    buscarVendasUnica,
    classificarBandeira,
    determinarModalidade,
    normalizeString
  }
}