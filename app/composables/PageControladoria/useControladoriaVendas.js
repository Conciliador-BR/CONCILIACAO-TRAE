import { ref, computed, watch } from 'vue'
import { useVendas } from '~/composables/useVendas'
import { useSecureLogger } from '~/composables/useSecureLogger'

export const useControladoriaVendas = () => {
  const { error: logError } = useSecureLogger()
  
  // Usar dados compartilhados da p√°gina vendas
  const { vendas, vendasOriginais, loading: vendasLoading, error: vendasError } = useVendas()
  
  // Estados reativos locais
  const vendasData = ref([])
  const loading = ref(false)
  const error = ref(null)
  
  // Fun√ß√£o para normalizar strings (remover acentos, espa√ßos, etc.)
  const normalizeString = (str) => {
    if (!str) return ''
    return str
      .toLowerCase()
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '')
      .replace(/[.\-_\s]/g, '')
  }
  
  // Ordem espec√≠fica para exibi√ß√£o das bandeiras
  const ordemBandeiras = [
    'VISA',
    'VISA ELECTRON', 
    'MASTERCARD',
    'MAESTRO',
    'ELO CR√âDITO',
    'ELO D√âBITO',
    'AMEX',
    'HIPERCARD',
    'BRADESCO D√âBITO',
    'TRICARD'
  ]
  
  // Fun√ß√£o para classificar bandeiras
  const classificarBandeira = (bandeira, modalidade) => {
    const bandeiraNorm = normalizeString(bandeira)
    const modalidadeNorm = normalizeString(modalidade)
    
    // VISA ELECTRON (D√©bito) - Captura todas as varia√ß√µes de d√©bito
    if (bandeiraNorm.includes('visa') && 
        (modalidadeNorm.includes('debito') || 
         modalidadeNorm.includes('debitoprepago') || 
         modalidadeNorm.includes('prepagodebito') ||
         modalidadeNorm.includes('prepagodbto') ||
         modalidadeNorm.includes('dbto') ||
         modalidadeNorm.includes('deb'))) {
      return 'VISA ELECTRON'
    }
    
    // VISA (Cr√©dito) - Apenas quando n√£o for d√©bito
    if (bandeiraNorm.includes('visa') && 
        !(modalidadeNorm.includes('debito') || 
          modalidadeNorm.includes('debitoprepago') || 
          modalidadeNorm.includes('prepagodebito') ||
          modalidadeNorm.includes('prepagodbto') ||
          modalidadeNorm.includes('dbto') ||
          modalidadeNorm.includes('deb'))) {
      return 'VISA'
    }
    
    // MAESTRO (D√©bito)
    if ((bandeiraNorm.includes('maestro') || bandeiraNorm.includes('mastercard') || bandeiraNorm.includes('master')) &&
        (modalidadeNorm.includes('debito') || modalidadeNorm.includes('debitoprepago'))) {
      return 'MAESTRO'
    }
    
    // MASTERCARD (Cr√©dito)
    if ((bandeiraNorm.includes('mastercard') || bandeiraNorm.includes('master')) && !modalidadeNorm.includes('debito')) {
      return 'MASTERCARD'
    }
    
    // ELO D√âBITO
    if (bandeiraNorm.includes('elo') && 
        (modalidadeNorm.includes('debito') || modalidadeNorm.includes('debitoprepago'))) {
      return 'ELO D√âBITO'
    }
    
    // ELO CR√âDITO
    if (bandeiraNorm.includes('elo') && !modalidadeNorm.includes('debito')) {
      return 'ELO CR√âDITO'
    }
    
    // BANESCARD D√âBITO
    if (bandeiraNorm.includes('banescard') && 
        (modalidadeNorm.includes('debito') || modalidadeNorm.includes('debitoprepago'))) {
      return 'BANESCARD D√âBITO'
    }
    
    // BRADESCO D√âBITO
    if (bandeiraNorm.includes('bradesco') && 
        (modalidadeNorm.includes('debito') || modalidadeNorm.includes('debitoprepago'))) {
      return 'BRADESCO D√âBITO'
    }
    
    // AMEX (sempre cr√©dito)
    if (bandeiraNorm.includes('amex') || bandeiraNorm.includes('american')) {
      return 'AMEX'
    }
    
    // HIPERCARD (sempre cr√©dito)
    if (bandeiraNorm.includes('hipercard') || bandeiraNorm.includes('hiper')) {
      return 'HIPERCARD'
    }
    
    // TRICARD (sempre cr√©dito)
    if (bandeiraNorm.includes('tricard') || bandeiraNorm.includes('tri')) {
      return 'TRICARD'
    }
    
    return 'OUTROS'
  }
  
  // Fun√ß√£o para determinar a modalidade de pagamento
  const determinarModalidade = (modalidade, numeroParcelas) => {
    const modalidadeNorm = normalizeString(modalidade)
    const parcelas = parseInt(numeroParcelas) || 1
    
    // Detecta todas as varia√ß√µes de d√©bito
    if (modalidadeNorm.includes('debito') || 
        modalidadeNorm.includes('debitoprepago') || 
        modalidadeNorm.includes('prepagodebito') ||
        modalidadeNorm.includes('prepagodbto') ||
        modalidadeNorm.includes('dbto') ||
        modalidadeNorm.includes('deb')) {
      return 'debito'
    }
    
    if (modalidadeNorm.includes('voucher') || modalidadeNorm.includes('alimentacao') || modalidadeNorm.includes('refeicao')) {
      return 'voucher'
    }
    
    // Cr√©dito baseado no n√∫mero de parcelas
    if (parcelas === 1) return 'credito'
    if (parcelas === 2) return 'credito2x'
    if (parcelas === 3) return 'credito3x'
    if (parcelas >= 4 && parcelas <= 6) return 'credito4x5x6x'
    
    return 'outros'
  }
  
  // Fun√ß√£o para processar dados de vendas (substituindo busca do Supabase)
  const processarDadosVendas = () => {
    console.log('üîÑ Processando dados de vendas para controladoria...')
    
    // Usar dados de vendas j√° carregados
    const dadosVendas = vendas.value || vendasOriginais.value || []
    console.log('üìä Dados de vendas dispon√≠veis:', dadosVendas.length, 'registros')
    
    if (dadosVendas.length === 0) {
      console.warn('‚ö†Ô∏è Nenhum dado de vendas dispon√≠vel')
      vendasData.value = []
      return []
    }
    
    // Mapear dados de vendas para formato esperado pela controladoria
    const dadosMapeados = dadosVendas.map(venda => {
      // Mapear campos da estrutura de vendas para estrutura da controladoria
      return {
        bandeira: venda.bandeira || venda.adquirente || '',
        modalidade: venda.modalidade || venda.tipoTransacao || '',
        numero_parcelas: venda.numeroParcelas || venda.parcelas || 1,
        valor_bruto: parseFloat(venda.vendaBruta || venda.valor_bruto || 0),
        valor_liquido: parseFloat(venda.vendaLiquida || venda.valor_liquido || 0),
        despesa_mdr: parseFloat(venda.despesaMdr || venda.mdr || 0),
        data_venda: venda.dataVenda || venda.data_venda || venda.data,
        empresa: venda.empresa || '',
        matriz: venda.matriz || ''
      }
    })
    
    console.log('üìã Primeiros 3 registros mapeados:', dadosMapeados.slice(0, 3))
    
    // Verificar se h√° registros VISA D√©bito
    const visaDebito = dadosMapeados.filter(item => 
      item.bandeira?.toLowerCase().includes('visa') && 
      item.modalidade?.toLowerCase().includes('debito')
    )
    console.log('üí≥ VISA D√©bito encontrados:', visaDebito.length, 'registros')
    
    if (visaDebito.length > 0) {
      const somaValorLiquido = visaDebito.reduce((sum, item) => sum + (parseFloat(item.valor_liquido) || 0), 0)
      const somaValorBruto = visaDebito.reduce((sum, item) => sum + (parseFloat(item.valor_bruto) || 0), 0)
      
      console.log('üí∞ Soma VISA D√©bito (Valor L√≠quido):', somaValorLiquido.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' }))
      console.log('üí∞ Soma VISA D√©bito (Valor Bruto):', somaValorBruto.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' }))
      
      // Mostrar alguns exemplos
      console.log('üìã Primeiros 5 registros VISA D√©bito:', visaDebito.slice(0, 5).map(item => ({
        bandeira: item.bandeira,
        modalidade: item.modalidade,
        valor_bruto: item.valor_bruto,
        valor_liquido: item.valor_liquido
      })))
    }
    
    vendasData.value = dadosMapeados
    return dadosMapeados
  }
  
  // Fun√ß√£o para buscar dados (mantendo compatibilidade com c√≥digo existente)
  const buscarVendasUnica = async (filtros = {}) => {
    loading.value = true
    error.value = null
    
    try {
      console.log('üîç Processando dados de vendas para controladoria...')
      console.log('üìã Filtros recebidos:', filtros)
      
      // Processar dados de vendas j√° carregados
      const dados = processarDadosVendas()
      
      console.log('‚úÖ Dados processados com sucesso:', dados.length, 'registros')
      return dados
      
    } catch (err) {
      console.error('‚ùå Erro ao processar dados de vendas:', err)
      error.value = `Erro ao processar dados: ${err.message}`
      logError('useControladoriaVendas', 'buscarVendasUnica', err)
      vendasData.value = []
      return []
      
    } finally {
      loading.value = false
    }
  }
  
  // Computed para agrupar dados por bandeira classificada
  const vendasAgrupadas = computed(() => {
    const grupos = {}
    
    console.log('üîÑ Processando', vendasData.value.length, 'registros para agrupamento')
    
    vendasData.value.forEach((venda, index) => {
      const bandeiraClassificada = classificarBandeira(venda.bandeira, venda.modalidade)
      const modalidadePagamento = determinarModalidade(venda.modalidade, venda.numero_parcelas)
      
      // Log detalhado para VISA
      if (venda.bandeira?.toLowerCase().includes('visa')) {
        console.log(`üìù VISA ${index + 1}:`, {
          bandeira_original: venda.bandeira,
          modalidade_original: venda.modalidade,
          bandeira_classificada: bandeiraClassificada,
          modalidade_pagamento: modalidadePagamento,
          valor_liquido: venda.valor_liquido
        })
      }
      
      if (!grupos[bandeiraClassificada]) {
        grupos[bandeiraClassificada] = {
          adquirente: bandeiraClassificada,
          debito: 0,
          credito: 0,
          credito2x: 0,
          credito3x: 0,
          credito4x5x6x: 0,
          voucher: 0,
          outros: 0,
          valor_bruto_total: 0,
          valor_liquido_total: 0,
          despesa_mdr_total: 0
        }
      }
      
      const grupo = grupos[bandeiraClassificada]
      const valorLiquido = parseFloat(venda.valor_liquido) || 0
      const valorBruto = parseFloat(venda.valor_bruto) || 0
      const despesaMdr = parseFloat(venda.despesa_mdr) || 0
      
      // Log espec√≠fico para VISA ELECTRON
      if (bandeiraClassificada === 'VISA ELECTRON') {
        console.log(`üí≥ Somando VISA ELECTRON:`, {
          modalidade: modalidadePagamento,
          valor_bruto: valorBruto,
          valor_liquido: valorLiquido,
          valor_anterior: grupo[modalidadePagamento],
          valor_novo: grupo[modalidadePagamento] + valorBruto
        })
      }
      
      // Somar valores por modalidade - USAR VALOR_BRUTO para as modalidades
      grupo[modalidadePagamento] += valorBruto
      grupo.valor_bruto_total += valorBruto
      grupo.valor_liquido_total += valorLiquido
      grupo.despesa_mdr_total += despesaMdr
    })
    
    const resultado = Object.values(grupos)
    console.log('üìä Resultado final do agrupamento:', resultado)
    
    // Log espec√≠fico para VISA ELECTRON
    const visaElectron = resultado.find(g => g.adquirente === 'VISA ELECTRON')
    if (visaElectron) {
      console.log('üí≥ VISA ELECTRON final na tabela:', visaElectron)
      console.log('üí∞ VISA ELECTRON D√©bito (valor que aparece na tabela):', 
        visaElectron.debito.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' }))
      console.log('üí∞ VISA ELECTRON Total Bruto:', 
        visaElectron.valor_bruto_total.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' }))
    } else {
      console.log('‚ö†Ô∏è VISA ELECTRON n√£o encontrado no resultado final')
    }
    
    // Ordenar resultado conforme a sequ√™ncia especificada
    const resultadoOrdenado = resultado.sort((a, b) => {
      const indexA = ordemBandeiras.indexOf(a.adquirente)
      const indexB = ordemBandeiras.indexOf(b.adquirente)
      
      // Se ambos est√£o na lista de ordem, usar a ordem especificada
      if (indexA !== -1 && indexB !== -1) {
        return indexA - indexB
      }
      
      // Se apenas A est√° na lista, A vem primeiro
      if (indexA !== -1 && indexB === -1) {
        return -1
      }
      
      // Se apenas B est√° na lista, B vem primeiro
      if (indexA === -1 && indexB !== -1) {
        return 1
      }
      
      // Se nenhum est√° na lista, manter ordem alfab√©tica
      return a.adquirente.localeCompare(b.adquirente)
    })
    
    console.log('üìã Resultado ordenado conforme sequ√™ncia especificada:', resultadoOrdenado.map(r => r.adquirente))
    
    return resultadoOrdenado
  })
  
  // Computed para totais gerais
  const totaisGerais = computed(() => {
    return vendasAgrupadas.value.reduce((acc, grupo) => {
      acc.vendaLiquida += grupo.valor_liquido_total
      acc.vendaBruta += grupo.valor_bruto_total
      acc.despesaMdr += grupo.despesa_mdr_total
      acc.debito += grupo.debito
      acc.credito += grupo.credito
      acc.credito2x += grupo.credito2x
      acc.credito3x += grupo.credito3x
      acc.credito4x5x6x += grupo.credito4x5x6x
      acc.voucher += grupo.voucher
      acc.outros += grupo.outros
      return acc
    }, {
      vendaLiquida: 0,
      vendaBruta: 0,
      despesaMdr: 0,
      debito: 0,
      credito: 0,
      credito2x: 0,
      credito3x: 0,
      credito4x5x6x: 0,
      voucher: 0,
      outros: 0
    })
  })
  
  // Watchers para sincroniza√ß√£o autom√°tica
  watch([vendas, vendasOriginais], () => {
    console.log('üîÑ Dados de vendas mudaram, atualizando controladoria...')
    processarDadosVendas()
  }, { immediate: true })
  
  // Sincronizar loading e error states
  watch(vendasLoading, (newLoading) => {
    loading.value = newLoading
  })
  
  watch(vendasError, (newError) => {
    error.value = newError
  })
  
  return {
    // Estados
    vendasData,
    loading,
    error,
    
    // Computed
    vendasAgrupadas,
    totaisGerais,
    
    // M√©todos
    buscarVendasUnica,
    processarDadosVendas,
    classificarBandeira,
    determinarModalidade,
    normalizeString
  }
}